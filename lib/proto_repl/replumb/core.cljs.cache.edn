;; Analyzed by ClojureScript 1.7.228
{:use-macros {with-compiler-env cljs.env.macros}, :excludes #{}, :name replumb.core, :imports nil, :requires {cljs cljs.js, cljs.js cljs.js, repl replumb.repl, replumb.repl replumb.repl, common replumb.common, replumb.common replumb.common}, :uses nil, :defs {read-eval-call {:protocol-inline nil, :meta {:file "/Users/jason/work/github_workspace/proto-repl/proto-repl-client-cljs/../lib/proto_repl/replumb/core.cljs", :line 7, :column 16, :end-line 7, :end-column 30, :export true, :arglists (quote ([callback source] [opts callback source])), :doc "Reads, evaluates and calls back with the evaluation result.\n\n  The first parameter is a map of configuration options, currently\n  supporting:\n\n  * `:verbose` will enable the the evaluation logging, defaults to false.\n  To customize how to print, use `(set! *print-fn* (fn [& args] ...)`\n\n  * `:warning-as-error` will consider a compiler warning as error\n  * `:target` `:nodejs` and `:browser` supported, the latter is used if\n  missing\n  * `:init-fn!` user provided initialization function, it will be passed a\n  map:\n\n          :form   ;; the form to evaluate, as data\n          :ns     ;; the current namespace, as symbol\n          :target ;; the current target\n\n  * `:load-fn!` will override replumb's default `cljs.js/*load-fn*`.\n  It rules out `:read-file-fn!`, losing any perk of using `replumb.load`\n  helpers. Use it if you know what you are doing and follow this\n  protocol:\n\n      ```\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n      ```\n\n  * `:read-file-fn!` an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found). It is mutually exclusive with `:load-fn!` and\n  will be ignored in case both are present\n\n  * `:write-file-fn!` a synchronous 2-arity function with signature\n  `[file-path data]` that accepts a file-path and data to write.\n\n  * `:src-paths` - a vector of paths containing source files\n\n  * `:cache` - a map containing two optional values: the first, `:path`,\n  indicates the path of the cached files. The second, `:src-paths-lookup?`,\n  indicates whether search the cached files in `:src-paths`. If both present,\n  `:path` will have the priority but both will be inspected.\n\n  * `:no-pr-str-on-value`  in case of `:success?` avoid converting the\n  result map `:value` to string\n\n  * `:context` - indicates the evaluation context that will be passed to\n  `cljs/eval-str`. Defaults to `:expr`.\n\n  * `:foreign-libs` - a way to include foreign libraries. The format is analogous\n  to the compiler option. For more info visit https://github.com/clojure/clojurescript/wiki/Compiler-Options#foreign-libs\n\n  The second parameter, `callback`, should be a 1-arity function which receives\n  the result map, whose result keys will be:\n\n  ```\n  :success?  a boolean indicating if everything went alright\n  :value     (if (:success? result)), this key contains the yielded value as\n             string, unless :no-pr-str-on-value is true, in which case it\n             returns the bare value.\n  :error     (if-not (:success? result)) will contain a js/Error\n  :warning   in case a warning was thrown and :warning-as-error is falsey\n  :form      the evaluated form as data structure (not string)}\n  ```\n\n  The third parameter is the source string to be read and evaluated.\n\n  It initializes the repl harness either on first execution or if an\n  option in `#{:src-paths :init-fn!}` changes from the previous\n  `read-eval-call`.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([callback source] [opts callback source]), :arglists ([callback source] [opts callback source]), :arglists-meta (nil nil)}}, :name replumb.core/read-eval-call, :variadic false, :file "../lib/proto_repl/replumb/core.cljs", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([callback source] [opts callback source]), :arglists ([callback source] [opts callback source]), :arglists-meta (nil nil)}, :method-params ([callback source] [opts callback source]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 7, :end-line 7, :max-fixed-arity 3, :fn-var true, :arglists ([callback source] [opts callback source]), :doc "Reads, evaluates and calls back with the evaluation result.\n\n  The first parameter is a map of configuration options, currently\n  supporting:\n\n  * `:verbose` will enable the the evaluation logging, defaults to false.\n  To customize how to print, use `(set! *print-fn* (fn [& args] ...)`\n\n  * `:warning-as-error` will consider a compiler warning as error\n  * `:target` `:nodejs` and `:browser` supported, the latter is used if\n  missing\n  * `:init-fn!` user provided initialization function, it will be passed a\n  map:\n\n          :form   ;; the form to evaluate, as data\n          :ns     ;; the current namespace, as symbol\n          :target ;; the current target\n\n  * `:load-fn!` will override replumb's default `cljs.js/*load-fn*`.\n  It rules out `:read-file-fn!`, losing any perk of using `replumb.load`\n  helpers. Use it if you know what you are doing and follow this\n  protocol:\n\n      ```\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n      ```\n\n  * `:read-file-fn!` an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found). It is mutually exclusive with `:load-fn!` and\n  will be ignored in case both are present\n\n  * `:write-file-fn!` a synchronous 2-arity function with signature\n  `[file-path data]` that accepts a file-path and data to write.\n\n  * `:src-paths` - a vector of paths containing source files\n\n  * `:cache` - a map containing two optional values: the first, `:path`,\n  indicates the path of the cached files. The second, `:src-paths-lookup?`,\n  indicates whether search the cached files in `:src-paths`. If both present,\n  `:path` will have the priority but both will be inspected.\n\n  * `:no-pr-str-on-value`  in case of `:success?` avoid converting the\n  result map `:value` to string\n\n  * `:context` - indicates the evaluation context that will be passed to\n  `cljs/eval-str`. Defaults to `:expr`.\n\n  * `:foreign-libs` - a way to include foreign libraries. The format is analogous\n  to the compiler option. For more info visit https://github.com/clojure/clojurescript/wiki/Compiler-Options#foreign-libs\n\n  The second parameter, `callback`, should be a 1-arity function which receives\n  the result map, whose result keys will be:\n\n  ```\n  :success?  a boolean indicating if everything went alright\n  :value     (if (:success? result)), this key contains the yielded value as\n             string, unless :no-pr-str-on-value is true, in which case it\n             returns the bare value.\n  :error     (if-not (:success? result)) will contain a js/Error\n  :warning   in case a warning was thrown and :warning-as-error is falsey\n  :form      the evaluated form as data structure (not string)}\n  ```\n\n  The third parameter is the source string to be read and evaluated.\n\n  It initializes the repl harness either on first execution or if an\n  option in `#{:src-paths :init-fn!}` changes from the previous\n  `read-eval-call`."}, get-prompt {:protocol-inline nil, :meta {:file "/Users/jason/work/github_workspace/proto-repl/proto-repl-client-cljs/../lib/proto_repl/replumb/core.cljs", :line 99, :column 16, :end-line 99, :end-column 26, :export true, :arglists (quote ([])), :doc "Retrieves the REPL prompt to display, according to the current\n  namespace. Returns a string."}, :name replumb.core/get-prompt, :variadic false, :file "../lib/proto_repl/replumb/core.cljs", :end-column 26, :method-params ([]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 99, :end-line 99, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Retrieves the REPL prompt to display, according to the current\n  namespace. Returns a string."}, error->str {:protocol-inline nil, :meta {:file "/Users/jason/work/github_workspace/proto-repl/proto-repl-client-cljs/../lib/proto_repl/replumb/core.cljs", :line 105, :column 16, :end-line 105, :end-column 26, :export true, :arglists (quote ([error] [error print-stack?])), :doc "Return the message string of the input `js/Error`.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([error] [error print-stack?]), :arglists ([error] [error print-stack?]), :arglists-meta (nil nil)}}, :name replumb.core/error->str, :variadic false, :file "../lib/proto_repl/replumb/core.cljs", :end-column 26, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([error] [error print-stack?]), :arglists ([error] [error print-stack?]), :arglists-meta (nil nil)}, :method-params ([error] [error print-stack?]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 105, :end-line 105, :max-fixed-arity 2, :fn-var true, :arglists ([error] [error print-stack?]), :doc "Return the message string of the input `js/Error`."}, unwrap-result {:protocol-inline nil, :meta {:file "/Users/jason/work/github_workspace/proto-repl/proto-repl-client-cljs/../lib/proto_repl/replumb/core.cljs", :line 110, :column 16, :end-line 110, :end-column 29, :export true, :arglists (quote ([result-map] [result-map include-warning?])), :doc "Unwraps the result of an evaluation.\n\n  It returns the content of `:value` in case of success and the content\n  of `:error` (a `js/Error`) in case of failure.\n\n  When `include-warning?` is true, then the value yields from, in order,\n  `:error`, then `:warning` and then eventually `:value`.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([result-map] [result-map include-warning?]), :arglists ([result-map] [result-map include-warning?]), :arglists-meta (nil nil)}}, :name replumb.core/unwrap-result, :variadic false, :file "../lib/proto_repl/replumb/core.cljs", :end-column 29, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([result-map] [result-map include-warning?]), :arglists ([result-map] [result-map include-warning?]), :arglists-meta (nil nil)}, :method-params ([result-map] [result-map include-warning?]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 110, :end-line 110, :max-fixed-arity 2, :fn-var true, :arglists ([result-map] [result-map include-warning?]), :doc "Unwraps the result of an evaluation.\n\n  It returns the content of `:value` in case of success and the content\n  of `:error` (a `js/Error`) in case of failure.\n\n  When `include-warning?` is true, then the value yields from, in order,\n  `:error`, then `:warning` and then eventually `:value`."}, success? {:protocol-inline nil, :meta {:file "/Users/jason/work/github_workspace/proto-repl/proto-repl-client-cljs/../lib/proto_repl/replumb/core.cljs", :line 128, :column 16, :end-line 128, :end-column 24, :export true, :arglists (quote ([result-map])), :doc "Given a `result-map`, tells whether the evaluation was successful."}, :name replumb.core/success?, :variadic false, :file "../lib/proto_repl/replumb/core.cljs", :end-column 24, :method-params ([result-map]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 128, :end-line 128, :max-fixed-arity 1, :fn-var true, :arglists (quote ([result-map])), :doc "Given a `result-map`, tells whether the evaluation was successful."}, result->string {:protocol-inline nil, :meta {:file "/Users/jason/work/github_workspace/proto-repl/proto-repl-client-cljs/../lib/proto_repl/replumb/core.cljs", :line 133, :column 16, :end-line 133, :end-column 30, :export true, :arglists (quote ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?])), :doc "Given a `result-map`, returns the result of the evaluation as string.\n\n  - When `include-warning?` is true, then the string yields from, in\n  order, `:error`, then `:warning` and then eventually `:value`.\n  - When `print-stack?` is true, the error string will include the stack\n  trace.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :arglists ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :arglists-meta (nil nil nil)}}, :name replumb.core/result->string, :variadic false, :file "../lib/proto_repl/replumb/core.cljs", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :arglists ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :arglists-meta (nil nil nil)}, :method-params ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :protocol-impl nil, :export true, :arglists-meta (nil nil nil), :column 1, :line 133, :end-line 133, :max-fixed-arity 3, :fn-var true, :arglists ([result-map] [result-map print-stack?] [result-map print-stack? include-warning?]), :doc "Given a `result-map`, returns the result of the evaluation as string.\n\n  - When `include-warning?` is true, then the string yields from, in\n  order, `:error`, then `:warning` and then eventually `:value`.\n  - When `print-stack?` is true, the error string will include the stack\n  trace."}, browser-options {:protocol-inline nil, :meta {:file "/Users/jason/work/github_workspace/proto-repl/proto-repl-client-cljs/../lib/proto_repl/replumb/core.cljs", :line 152, :column 16, :end-line 152, :end-column 31, :export true, :arglists (quote ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!])), :doc "Creates the browser option map for read-eval-call.\n\n  The 1-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 2-arity function accepts a sequence of source path strings and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found).\n\n  The 3-arity function receives additionally a third parameter `write-file-fn!`,\n  a synchronous 2-arity function with signature `[file-path data]` that accepts\n  a file-path and data to write.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :arglists ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :arglists-meta (nil nil nil)}}, :name replumb.core/browser-options, :variadic false, :file "../lib/proto_repl/replumb/core.cljs", :end-column 31, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :arglists ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :arglists-meta (nil nil nil)}, :method-params ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :protocol-impl nil, :export true, :arglists-meta (nil nil nil), :column 1, :line 152, :end-line 152, :max-fixed-arity 3, :fn-var true, :arglists ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :doc "Creates the browser option map for read-eval-call.\n\n  The 1-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 2-arity function accepts a sequence of source path strings and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found).\n\n  The 3-arity function receives additionally a third parameter `write-file-fn!`,\n  a synchronous 2-arity function with signature `[file-path data]` that accepts\n  a file-path and data to write."}, nodejs-options {:protocol-inline nil, :meta {:file "/Users/jason/work/github_workspace/proto-repl/proto-repl-client-cljs/../lib/proto_repl/replumb/core.cljs", :line 199, :column 16, :end-line 199, :end-column 30, :export true, :arglists (quote ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!])), :doc "Creates the Node.js option map for read-eval-call.\n\n  The 1-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 2-arity function accepts a sequence of source path strings and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found).\n\n  The 3-arity function receives additionally a third parameter `write-file-fn!`,\n  a synchronous 2-arity function with signature `[file-path data]` that accepts\n  a file-path and data to write.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :arglists ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :arglists-meta (nil nil nil)}}, :name replumb.core/nodejs-options, :variadic false, :file "../lib/proto_repl/replumb/core.cljs", :end-column 30, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :arglists ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :arglists-meta (nil nil nil)}, :method-params ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :protocol-impl nil, :export true, :arglists-meta (nil nil nil), :column 1, :line 199, :end-line 199, :max-fixed-arity 3, :fn-var true, :arglists ([load-fn!] [src-paths read-file-fn!] [src-paths read-file-fn! write-file-fn!]), :doc "Creates the Node.js option map for read-eval-call.\n\n  The 1-arity function requires a `load-fn!` compatible with\n  ClojureScript `cljs.js/*load-fn*`. Use it if you know what you are\n  doing and follow this protocol:\n\n      Each runtime environment provides a different way to load a library.\n      Whatever function `*load-fn*` is bound to will be passed two arguments\n      - a map and a callback function: The map will have the following keys:\n\n          :name   - the name of the library (a symbol)\n          :macros - modifier signaling a macros namespace load\n          :path   - munged relative library path (a string)\n\n      The callback cb, upon resolution, will need to pass the same map:\n\n          :lang       - the language, :clj or :js\n          :source     - the source of the library (a string)\n          :cache      - optional, if a :clj namespace has been precompiled to\n                        :js, can give an analysis cache for faster loads.\n          :source-map - optional, if a :clj namespace has been precompiled\n                        to :js, can give a V3 source map JSON\n\n      If the resource could not be resolved, the callback should be invoked with\n      nil.\n\n  The 2-arity function accepts a sequence of source path strings and\n  `read-file-fn!`, an asynchronous 2-arity function with signature\n  `[file-path src-cb]` where src-cb is itself a function `(fn [source]\n  ...)` that needs to be called with the file content as string (`nil`\n  if no file is found).\n\n  The 3-arity function receives additionally a third parameter `write-file-fn!`,\n  a synchronous 2-arity function with signature `[file-path data]` that accepts\n  a file-path and data to write."}}, :require-macros {cljs.env.macros cljs.env.macros, cljs cljs.js, cljs.js cljs.js}, :cljs.analyzer/constants {:seen #{:read-file-fn! :default :value :write-file-fn! :nodejs :warning :error :load-fn! :target :success? :src-paths}, :order [:error :value :warning :success? :target :load-fn! :default :read-file-fn! :src-paths :write-file-fn! :nodejs]}, :doc nil}